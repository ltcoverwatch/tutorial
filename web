
2020.11.02

docker run --name zoom01back -d -p 8888:8888 -t --link zoom_mysql:zoom_mysql springboot/zoom01

docker springboot 连接同为docker的数据库
--link mysql容器名:yml文件配置的连接地址名

查看linux内存cpu占用等命令： top
vi filename :打开或新建文件

***第一次配置nginx，要打开防火墙80端口，并且重启
firewall-cmd --zone=public --add-port=80/tcp --permanent
firewall-cmd --reload

--------------

upstream my_server {                                                         
    server 172.24.5.179:8888;                                                
    keepalive 2000;
}
server {
    listen       80;                                                         
    server_name  172.24.5.180;                                               
    client_max_body_size 1024M;

    location / {
        proxy_pass http://my_server/;
        proxy_set_header Host $host:$server_port;
    }
}

-----------------------------------------------

2020.11.11

el-menu 动态导航时
el-menu内部这样写，这里要用template做最外层。
可以理解为template是一个虚标签，而el-menu-item等是实标签
这里不能将template变成div或者span，会发生一个导航独占一行的问题
        <template v-for="nav in navObjList">
            <el-submenu :index="nav.navId" v-if="nav.children.length != 0" :key="nav.navId">
                <template slot="title">{{ nav.navName }}</template>
                <el-menu-item v-for="child in nav.children" :key="child.navId" :index="child.navId">{{ child.navName }}</el-menu-item>
            </el-submenu>
            <el-menu-item :index="nav.navId" v-else :key="nav.navId">{{ nav.navName }}</el-menu-item>
        </template>

Element-UI 回到顶部el-backtop
官方文档巨坑无比，但是配置成功了后很好用
<template>
  <el-backtop target=".page-component__scroll .el-scrollbar__wrap"></el-backtop>
</template> 

html,body {
  height: 100%;
}
#app {
 height: 100%;
}
.page-component__scroll {
   height: 100%;
} 
.el-scrollbar__wrap {
    overflow: scroll;
    height: 100%;
} 

以上这些要配置好
.page-component__scroll标在app的div上
.el-scrollbar__wrap标在小组件应用页面整体的div上

------------------------------
2020.11.12

docker查看控制台信息 docker logs <ContainerName>
-------------------------------
2020.11.13

jpa中的一对多
在不考虑兼职的情况下，每名员工对应一家公司，每家公司有多名员工。
习惯把一的一方称之为主表，把多的一方称之为从表
**什么是外键？**指的是从表中有一列，取值参照主表中的主键，这一列就是外键。

----------
2020.11.16

参考文章 https://blog.csdn.net/u013066244/article/details/96443952
时差变换
String time = "2020-11-13 01:00:00";
String timezone = "Asia/Tokyo";

DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
LocalDateTime localDateTime = LocalDateTime.parse(time, formatter);

OffsetDateTime offsetDateTime = ZonedDateTime
				.of(localDateTime, ZoneId.of(timezone))
				.toOffsetDateTime();
------------------------------
2020.11.19

redis文章 https://juejin.im/post/6844903962504609805
除redis依赖外还需要引入commons-pool2，否则报错
		<dependency>
			<groupId>org.apache.commons</groupId>
			<artifactId>commons-pool2</artifactId>
		</dependency>
		<!-- Redis -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-redis</artifactId>
		</dependency>


序列化实体类时，private static final long serialVersionUID = 5237730257103305078L; 是什么意思？
serialVersionUID 用来表明类的不同版本间的兼容性，说白了：就是来比较版本用的，为了不让程序报出版本不一致错误

在进行反序列化时，JVM(推荐进一步了解JVM的结构原理)会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。

docker 进入容器
sudo docker exec -it 775c7c9ee1e1 /bin/bash

当实现java.io.Serializable接口的实体（类）没有显示定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本用来做比较使用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID 。

因为在实际的开发中，不希望通过编译来强制划分软件版本，
即实现序列化接口的实体能够兼容先前版本，未作更改的类，就需要显式地定义一个名为serialVersionUID，类型为long的变量
，不修改这个变量值的序列化实体都可以相互进行串行化和反串行化。

------------
缓存cache
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-cache</artifactId>
		</dependency>

程序入口标注 @EnableCaching
service的方法上标注@Cacheable @CachePut @CacheEvict等等
