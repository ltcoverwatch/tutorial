
    public static void main(String[] args) {
        Animal animal = new Dog();   //父类指向子类
        System.out.println(animal.name);    //成员变量，包括静态变量    静态绑定，编译阶段已绑定，与父类绑定 输出 animal name
        System.out.println(animal.staticName); //同上 输出 animal static name
        animal.eat(); //实例方法，动态绑定 输出 dog eat
        animal.staticEat();//静态方法，静态绑定 输出 animal static eat
    }
    
实例方法与引用变量实际引用的对象的方法进行绑定，这种绑定属于动态绑定，因为是在运行时由 Java 虚拟机动态决定的。例如，animal.eat() 是将 eat() 方法与 Cat 类绑定。
静态方法与引用变量所声明的类型的方法绑定，这种绑定属于静态绑定，因为是在编译阶段已经做了绑定。例如，animal.staticEat() 是将 staticEat() 方法与 Animal 类进行绑定。
成员变量（包括静态变量和实例变量）与引用变量所声明的类型的成员变量绑定，这种绑定属于静态绑定，因为在编译阶段已经做了绑定。例如，animal.name 和 animal.staticName 都是与 Animal 类进行绑定。

public class AutoCloseTest {
    public static void main(String[] args) throws IOException {
        try (
                // 声明、初始化两个可关闭的资源
                // try语句会自动关闭这两个资源
                BufferedReader br = new BufferedReader(new FileReader("AutoCloseTest.java"));
                PrintStream ps = new PrintStream(new FileOutputStream("a.txt"))) {
            // 使用两个资源
            System.out.println(br.readLine());
            ps.println("C语言中文网");
        }
    }
}

包含了隐式的 finally 块，没catch finally 也行

springboot 事件监听
参考 https://blog.csdn.net/pengjunlee/article/details/79394730
1.自定义事件 


import org.springframework.context.ApplicationEvent;
 
/**
 * 自定义事件，继承 ApplicationEvent
 * @author pjli
 */
public class MyApplicationEvent extends ApplicationEvent {
 
	private static final long serialVersionUID = 1L;
 
	public MyApplicationEvent(Object source) {
		super(source);
		System.out.println("触发 MyApplicationEvent 事件...");
	}
 
第二步：定义事件监听器，一般是实现 ApplicationListener 接口。

import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;
 
/**
 * 事件监听器，实现 ApplicationListener 接口
 * @author pjli
 */
 
@Component
public class MyApplicationListener implements ApplicationListener<MyApplicationEvent>{
 
	
	@Override
	public void onApplicationEvent(MyApplicationEvent event) {
		System.out.println("监听到："+event.getClass().getName()+"事件...");
	}
} 

第三步：注册监听器 使用 @Component 等注解将事件监听器纳入到 Spring 容器中管理。

第四步 发布事件

@SpringBootApplication
public class MyApplication {
	public static void main(String[] args) {
		ConfigurableApplicationContext context = SpringApplication.run(MyApplication.class, args);
		// 注册 MyApplicationListener 事件监听器 （注意：这步其实不需要，用component注解已经注入了）
		context.addApplicationListener(new MyApplicationListener());
		// 发布 MyApplicationEvent 事件
		context.publishEvent(new MyApplicationEvent(new Object()));
		// context.getBean(MyEventHandler.class).publishMyApplicationEvent();
		context.close();
	}
-----------------------------------


jpa原生sql查询时，@Query（，nativeQuery = true）要赋值为真，否则报错

定时任务文章
https://blog.csdn.net/zyb2017/article/details/76223385


跨域-前端配置
        proxy: {
            '/api': {
                target: 'http://172.24.6.155:8888/api',
                changeOrigin: true,
                ws: true,
                pathRewrite:{
                    '^/api': ''
                }
            }
        }
